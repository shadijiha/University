<html>
	<head>
		<title>^_^</title>
		<style type="text/css">
			#input {
				border: solid black 1px;
				width: 50%;
				height: 50%;
				padding: 15px;
			}
		</style>
	</head>
	<body>
		<button id="underline"><u>U</u></button>
		<button id="bold" OnClick="bolder()"><b>B</b></button>
		<button id="italic"><i>I</i></button>
		<br />
		<br />
		<div id="input" contenteditable="true">Place holder</div>
		<button OnClick="callParser();">Parse</button>
		<script>
			Array.prototype.insert = function(index, item) {
				this.splice(index, 0, item);
			};

			class TextareaElement {
				constructor(str, index) {
					this.text = str;
					this.bold = false;
					this.italic = false;
					this.underline = false;
					this.index = index;
				}

				getText() {
					return this.text;
				}

				getIndex() {
					return this.index;
				}

				setText(newText) {
					this.text = newText;
				}

				isBold() {
					return this.bold;
				}

				isItalic() {
					return this.italic;
				}

				isUnderline() {
					return this.underline;
				}

				setBold() {
					this.bold = true;
				}

				setItalic() {
					this.italic = true;
				}

				setUnderline() {
					this.underline = true;
				}

				toggleBold() {
					this.bold = !this.bold;
				}

				toggleItalic() {
					this.bold = !this.bold;
				}

				toggleUnderline() {
					this.bold = !this.bold;
				}
			}

			class Textarea {
				constructor(HTMLelement) {
					this.buffer = [];
					this.HTMLelement = HTMLelement || null;
					this.splitter = " ";
				}

				static createElement(
					str,
					index,
					bold = false,
					italic = false,
					underline = false
				) {
					let temp = new TextareaElement(str, index);
					bold ? temp.toggleBold() : false;
					italic ? temp.toggleItalic() : false;
					underline ? temp.toggleUnderline() : false;

					return temp;
				}

				addToBuffer(textareaElement, index) {
					if (index == null || index == undefined) {
						this.buffer.push(textareaElement);
					} else {
						this.buffer.insert(index, textareaElement);
					}
				}

				removeFromBuffer(textareaElement) {
					return this.buffer.splice(this.buffer.indexOf(textareaElement), 1);
				}

				replaceInBuffer(oldTextAreaElement, newTextAreaElement) {
					for (const [i, temp] of this.buffer.entries()) {
						if (temp == oldTextAreaElement) {
							this.buffer[i] = newTextAreaElement;
						}
					}
				}

				searchInBuffer(dataToSearch) {
					for (const [i, temp] of this.buffer.entries()) {
						let condition = false;
						if (dataToSearch instanceof TextareaElement) {
							if (temp == dataToSearch) {
								return { result: temp, index: i };
							}
						} else {
							if (temp.getText() == dataToSearch)
								return { result: temp, index: i };
						}
					}
					return null;
				}

				clearBuffer() {
					this.buffer = [];
				}

				swapElements(textareaElement1, textareaElement2) {
					this.buffer[i] = textareaElement2;
					this.buffer[textareaElement2.index] = textareaElement1;
				}

				/**
				 * This function gets the location of the text that you passe pass
				 * as an argument
				 * @param dataOfText The text you want to find the start and ending * index inside the textarea buffer
				 * @return {firstIndex: NUMBER, lastIndex: NUMBER}
				 */
				getTextLocation(dataOfText) {
					let { text, length } = dataOfText;
					length = text.split(this.splitter).length - 1;

					// Get the first index of the text
					let string = this.HTMLelement.textContent;
					string = string.split(text);

					const firstIndex = string[0].split(this.splitter).length;

					return { firstIndex: firstIndex, lastIndex: length };
				}

				/**
				 * This function toggles BOLD on all the elements in the buffer that * are contained between 2 indeces
				 * @param indecesData The starting index and last index of the range
				 * to set to bold
				 * Has to be like that: {firstIndex: NUMBER, lastIndex: NUMBER}
				 */
				toggleTextRangeBold(indecesData) {
					const { firstIndex, lastIndex } = indecesData;
					// Modify all text that passes throw the offset
					for (let i = firstIndex; i < firstIndex + lastIndex; i++) {
						this.buffer[i].toggleBold();
					}
				}

				parseContent() {
					let text = this.HTMLelement.textContent;
					text = text.split(this.splitter);

					for (const [i, string] of text.entries()) {
						if (this.searchInBuffer(string) == null) {
							this.addToBuffer(Textarea.createElement(string, i));
						}
					}
				}

				render() {
					this.HTMLelement.innerHTML = "";

					for (const [i, temp] of this.buffer.entries()) {
						let strBefore = "";
						let strEnd = "";

						if (temp.isBold()) {
							strBefore += "<b>";
							strEnd += "</b>";
						}
						if (temp.isItalic()) {
							strBefore += "<i>";
							strEnd += "</i>";
						}
						if (temp.isUnderline()) {
							strBefore += "<u>";
							strEnd += "</u>";
						}

						// Add splitter only if it is not the last element
						if (i < this.buffer.length - 1) strEnd += this.splitter;

						this.HTMLelement.innerHTML += strBefore + temp.getText() + strEnd;
					}
				}
			}

			/**
			 * This function gets the selected text in window and it length
			 * @return {text: THE SELECTED TEXT, length: THE LENGTH OF THE TEXT}
			 */
			function getSelectedText() {
				let text = window.getSelection().focusNode.data;
				let length = window.getSelection().focusNode.length;
				return { text, length };
			}

			/**
			 * This is the main function that calls everything
			 */
			const myRichTextarea = new Textarea(document.getElementById("input"));
			function callParser() {
				myRichTextarea.parseContent();
				myRichTextarea.buffer[0].setBold();
				myRichTextarea.render();
			}

			function bolder() {
				myRichTextarea.parseContent();
				myRichTextarea.toggleTextRangeBold(
					myRichTextarea.getTextLocation(getSelectedText())
				);
				myRichTextarea.render();
			}
		</script>
	</body>
</html>
